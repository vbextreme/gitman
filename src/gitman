#!/usr/bin/env perl

our $VERSION = 0.0;

=pod

=head1 NAME

gitman v$VERSION

=head2 SYNOPSIS

Git Manager

=head2 INSTALL
fedora perl-json
debian/ubuntu libjson-perl

=head2 USAGE

=head2 COPYRIGHT

Copyright vbextreme 2017
License gplv3

=cut

###############################################################################
###############################################################################
################################ PACKAGE GIT ##################################
###############################################################################
###############################################################################

package GIT;
use strict;
use warnings;
use Cwd;

sub new{
    my $class = shift;
    
    my $self = {
		repository => undef,
		remote => 'origin',
		branch => 'master',
		tag => undef,
		prefix => undef,
		name => undef,
		backdir => undef
    };
    
                
    bless $self, $class;
    return $self;
}    

sub _saveDir{
	my ($self) = @_;
	$self->{backdir} = getcwd;
}

sub _restoreDir{
	my ($self) = @_;
	chdir $self->{backdir};
}

sub _toPrefix{
	my ($self) = @_;
	chdir $self->{prefix}  or die "prefix $self->{sources} not exists\n";
}

sub _toRepo{
	my ($self) = @_;
	my $dir = $self->{prefix} . '/' . $self->{name};
	chdir $dir or die "directory $dir not exists\n";
}

sub clone{
	my ($self) = @_;
	$self->_saveDir;
	$self->_toPrefix;
	system("git clone -b $self->{branch} $self->{repository} $self->{name}");
	die "fail git clone $self->{repository}\n" if $?;
	if (defined $self->{tag} && $self->{tag} ne ''){
		$self->_toRepo;
		system("git checkout tags/$self->{tag}");
		die "fail git tags $self->{repository}\n" if $?;
	}
	$self->_restoreDir;
}

sub fork{
	my ($self) = @_;
	$self->_saveDir;
	$self->_toPrefix;
	system("git clone -b $self->{branch} $self->{repository} $self->{name}");
	die "fail git fork $self->{repository}\n" if $?;
	if (defined $self->{tag} && $self->{tag} ne ''){
		$self->_toRepo;
		system("git checkout tags/$self->{tag}");
		die "fail git tags $self->{repository}\n" if $?;
	}
	$self->_restoreDir;
}

sub pull{
	my ($self) = @_;
	$self->_saveDir;
	$self->_toRepo;
	system("git pull origin $self->{branch}");
	die "fail git pull $self->{name}\n" if $?;
	$self->_restoreDir;
}

sub upgrade{
	my ($self, $fork) = @_;
	if( -d $self->{prefix} . '/' . $self->{name}){
		$self->pull;
	}
	else{
		if ( defined $fork ){
			$self->fork;
		}
		$self->clone;
	}
}

1;

###############################################################################
###############################################################################
############################## PACKAGE MANAGER ################################
###############################################################################
###############################################################################

package PMAN;
use strict;
use warnings;

sub new{
    my $class = shift;
	my $distro = shift;
    
    my $self = {
		dpm => {
			fedora => 'dnf',
			ubuntu => 'apt',
			debian => 'apt',
			arch => 'pacman'
		},
		pmi => { 
			dnf => 'install',
			apt => 'install',
			pacman => '-S'
		},
		distro => $distro
    };
           
    bless $self, $class;
    return $self;
}    

sub install{
	my ($self, @pk) = @_;
	my $dpm = $self->{dpm}->{$self->{distro}};
    my $pmi = $self->{pmi}->{$dpm};
	my $inl = join(' ',@pk);
	
	system("$dpm $pmi $inl");
	die "fail to install dependency\n" if $?;
}

1;

##############################################################################
##############################################################################
################################# GITMAN #####################################
##############################################################################
##############################################################################

use strict;
use warnings;
use Cwd;
use JSON;

my $GITMAN_DIR = '/etc/gitman';
my $GITMAN_CONFIG = "$GITMAN_DIR/config.json";

my %OPT = (
	help => \&gmUsage,
	dependency => \&gmDependency,
	upgrade => \&gmUpgrade
);

my $config = loadJson($GITMAN_CONFIG);
$config->{distro} = distroName() if not exists $config->{distro} or $config->{distro} eq '';
$config->{jobs} = ncore() + 1 if not exists $config->{jobs} or $config->{jobs} eq '';

push @ARGV, 'help' if scalar @ARGV < 1;

gmUsage() unless exists $OPT{$ARGV[0]};

$OPT{$ARGV[0]}->();

sub gmUsage{
	print "todo\n";
	exit 0;
}

sub depsInstall{
	my ($hdep) = @_;
	my $pm = PMAN->new($config->{distro}); 
	my $localDistro = $config->{distro};
	unless (exists $hdep->{$localDistro}){
		$localDistro = 'common' ;
		die "unable to get dependency\n" unless exists $hdep->{$localDistro};
	}
	$pm->install(@{$hdep->{localDistro}});
}

sub gmDependency{
	gmUsage() unless defined $ARGV[1];
	my ($fjson) = $ARGV[1];
	my $json = loadJson($config->{repoprefix} . "/${fjson}.json");
	depsInstall($json->{dependency}) if $json->{dependency};
}

sub gmUpdate{
	my $git = GIT->new();
	$git->{name} = $->{name};
	$git->{repository} = $->{repository};
	$git->{branch} = $->{branch};
	$git->{tag} = $->{tag};
	$git->{prefix} = $GITMAN_DIR;

	$git->upgrade 1;
}

sub gmUpgrade{
	gmUsage() unless defined $ARGV[1];
	my ($fjson) = $ARGV[1];
	my $json = loadJson($config->{repoprefix} . "/${fjson}.json");
	
	my $git = GIT->new();
	$git->{name} = $json->{name};
	$git->{repository} = $json->{repository};
	$git->{branch} = $json->{branch};
	$git->{tag} = $json->{tag};
	$git->{prefix} = $config->{sources};

	$git->upgrade;

	#build
}

##############################################################################
##############################################################################
################################## INUTILITY #################################
##############################################################################
##############################################################################

sub loadJson{
	my ($fname) = @_;
	print "fname=$fname\n";
	my $olds = $/;
	local $/=undef;
	open my $fd, '<', $fname or die "unable to open $fname\n$!\n";
	my $sjs = <$fd>;
	$/ = $olds;
	return decode_json $sjs;
}

sub distroName{
	my $osr = '/etc/os-release';
	die "can't recognize distro\n" unless -f $osr;
	open my $fd, '<', $osr or die "cant open $osr\n$!\n";
	while( <$fd> ){
		return $1 if /ID=([a-z]+)/;
	}
	die "can't get distro id\n";
}

sub ncore{
	open my $fd, '<', '/proc/cpuinfo' or die "fail to open cpuinfo\n$!\n";
	return scalar(map /^processor/, <$fd>);
}
